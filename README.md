# Система управления новостями

## Микросервис micro-comments, работающий непосредственно с комментариями

Является частью общей системы
- [ News Management System](https://github.com/rusakovich-viktar/news-management-system/tree/develop)

### Основные сущности и назначение:

-	comment содержит поля: id, time, text, username и news_id.
- CRUD для работы с комментариями
- просмотр списка комментариев (с пагинацией)

### Стек технологий, примененный в micro-comments

- Использованы Spring Boot 3.2.3, Java 17, Gradle 8.5 и PostgreSQL 15.1; 
-  Spring Data JPA, Hibernate validator, Spring Web, liquibase, mapstruct, redis, spring-cloud-openFeign, spring-cloud-config-client, lombok
    -  Для тестирования использованы spring-boot-testcontainers, junit5, Mockito, Wiremock

### Реализация. Общие пояснения к деталям

Микросервис получает конфиги из micro-config-server-cloud сервиса, поэтому необходимо чтобы сервер с конфигами при
старте данного микросервиса работал.

### Используется одна база данных, к каждой таблице которой обращается свой микросервис

![структура](https://github.com/rusakovich-viktar/NMS-resourses/raw/rusakovich-viktar-patch-1/Снимок%20экрана%202024-03-04%20151246.jpg)

### Реализованы и подключены два Spring Boot Starter:


- logger-aspect-starter реализует логирование запрос-ответ в аспектном стиле (для слоя Controlles)
- exception-handler-starter реализует глобальную обработку исключений и интерпретацию их согласно REST.
- Стартеры при сборке загружаются первыми, далее из локального репозитория .m2 как зависимости подключаются к другим микросервисам.


### Подключен Liquibase для тестирования persistence cлоя. База для @Profile prod и @Profile dev накатывается при загрузке сервиса новостей


-  при запуске тестов подхватывается скрипт по генерации необходимых таблиц + дополнительно из sql файлов заполняются таблицы во время тестирования.
- Реализовано - через разные changelog и контексты Liquibase. Для тестов подхватывается еще скрипт наполнения таблиц.
 

### Создана и подключена реализация кэша, для хранения сущностей:


Самописный кеш реализован согласно заданию через Proxy с использованием AOP. Подключен для микросервисов новостей и комментариев в @Profile dev.


### Подключен кэш провайдер Redis (в docker):


Подключен для микросервисов новостей и комментариев в @Profile prod.


### Документация swagger доступна по пути `/api`

```
Код документирован @JavaDoc, подключен Swagger (OpenAPI 3.0)
```

### Тестирование. Сервисный слой покрыт на 100%, весь код 85-87%.

![news-coverage](https://github.com/rusakovich-viktar/NMS-resourses/raw/rusakovich-viktar-patch-1/com-coverage.jpg)

    Использованы testcontainers в тестах persistence layer (для БД)
 	Написаны интеграционные тесты
    Использован WireMock в тестах для слоя clients (ответ от микросервиса новостей)

    Для тестирования порты 8081 и 8082 должны быть свободны, чтобы не мешать поднятию контекста.    
    Также для тестирования база данных поднималась локально. Тестирование проводится в @Profile dev.

### Использован Docker, написан DockerFile


Написаны Dockerfile – для каждого spring boot приложения, создан общий docker-compose.yml для поднятия всех сервисов в контейнерах, настроено взаимодействие между ними)

### Реализована поддержка @Profile prod и dev. Конфиги вынесены в Spring Cloud Config:

- В контексте приложения условно будем считать что профиль prod будет применяться для запуска и взаимодействия микосервисов в docker сети.
Для локальной разработки, а также для тестирования будем использовать профиль dev.
- Профили конфигурируются через micro-config-server-cloud, поэтому он должен быть запущен или в контейнере для профиля prod или локально для профиля dev.
- Для смены профиля dev(локально и тесты) и prod(в докере) необходимо в папка проекта в application.yml сменить активный профиль на 
  - profiles: active: dev 
    - или 
  - profiles: active: prod

___
- добавлено:

Для запуска проекта локально изменил конфиг для доступа к базе в контейнере, а не локально. После запуска проекта для работы с dev профилем оставьте работать контейнеры с базой данных и эластиком. Остальные сервисы можно перезапустить локально, предварительно сменив профиль на dev
___

# Как запустить приложение

Является частью сервиса по управлению комментариями, запускать совместно с прочими микросервисами по инструкции
из [News Management System](https://github.com/rusakovich-viktar/news-management-system/tree/develop)

- Порт для запуска `8082`
- должен быть запущен сервис новостей и база данных

Можно обращаться напрямую по http://localhost:8082/comments, но так как реализован доступ к сервису через gateway, после
полного запуска всех микросервисов можно выполнять все те же операции через gateway http://localhost:8080/comments/*

## ЭНДПОИНТЫ И ИНТЕРФЕЙС

Все эндпоинты выполнены с учетом требований REST, Документация swagger доступна по пути `/api`

<details>
 <summary><strong>
 подробнее - раскрывающийся список эндпоинтов
</strong></summary>

#### 1. POST запрос на http://localhost:8082/comments/news/{newsId} типа
http://localhost:8082/comments/news/1

```
{
    "username": "имя_необязательно",
    "text": "Текст комментария"
}
```
или 
```
{
    "text": "Текст комментария"
}
```

создает новый комментарий для новости 1 и возвращает ответ типа, добавляя текущее время создания и обновления комментария, а также id комментария из бд.

```
{
    "id": 207,
    "time": "2024-03-07T01:30:00.0120091",
    "updateTime": "2024-03-07T01:30:00.0120091",
    "text": "Текст комментария",
    "username": "имя_необязательно",
    "newsId": 1
}
```
или такой, если имя пользователя не указано
```
{
    "id": 208,
    "time": "2024-03-07T01:31:18.3811376",
    "updateTime": "2024-03-07T01:31:18.3811376",
    "text": "Текст комментария",
    "username": "anonymous",
    "newsId": 1
}
```

#### 2. GET запрос на http://localhost:8082/comments/{commentsId}, где commentsId = 11, даст ответ с возвратом Id новости, к которой данный комментарий относится
типа
```
{
    "id": 11,
    "time": "2024-02-29T17:34:51.185191",
    "updateTime": "2024-02-29T17:34:51.185191",
    "text": "первый",
    "username": "user1",
    "newsId": 2
}
```
#### 3. GET запрос на http://localhost:8082/comments, вернет список комментариев, по умолчанию 20 на странице
- можно настроить пагинацию, например, добавив к запросу `?page=0&size=3`, где page номер страницы с 0, а size количество отображаемых комментариев на странице
- получим ответ типа:
```
{
    "content": [
        {
            "id": 1,
            "time": "2024-02-29T17:34:51.185191",
            "updateTime": "2024-02-29T17:34:51.185191",
            "text": "первый",
            "username": "user1",
            "newsId": 1
        },
        {
            "id": 2,
            "time": "2024-02-29T17:34:51.185191",
            "updateTime": "2024-02-29T17:34:51.185191",
            "text": "хорошая статья",
            "username": "user2",
            "newsId": 1
        },
        {
            "id": 3,
            "time": "2024-02-29T17:34:51.185191",
            "updateTime": "2024-02-29T17:34:51.185191",
            "text": "неплохо",
            "username": "user3",
            "newsId": 1
        }
    ],
    "pageable": {
        "pageNumber": 0,
        "pageSize": 3,
        "sort": [],
        "offset": 0,
        "unpaged": false,
        "paged": true
    },
    "last": false,
    "totalPages": 63,
    "totalElements": 187,
    "size": 3,
    "number": 0,
    "sort": [],
    "first": true,
    "numberOfElements": 3,
    "empty": false
}
```
#### 4. PUT запрос на http://localhost:8082/comments/{commentsId}, где commentsId = 134 с телом

```
{
    "username": "измененное имя",
    "text": "измененный Текст комментария"
}

```

обновит поля новости с id = 10 и возвращает ответ типа, обновляя данные поля, а также поле updateTime, устанавливая текущее время.

```
{
    "id": 134,
    "time": "2024-02-29T17:34:51.185191",
    "updateTime": "2024-03-07T01:36:03.442177",
    "text": "измененный Текст комментария",
    "username": "измененное имя",
    "newsId": 14
}
```
#### 5.  DELETE запрос на http://localhost:8082/comments/{commentsId}, где newsId = 145 даст ответ без тела, со статусом 201 No Content
- повторный запрос на этот же адрес будет возвращать один и тот же ответ, так как запрос **идемпотентный**, что и требуется по REST,
```
{
    "timestamp": "2024-03-07T01:39:25.3622765",
    "status": 404,
    "error": "Not Found",
    "message": "Comment with id 145 does not exist"
}
```
</details>